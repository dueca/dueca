/* ------------------------------------------------------------------ */
/*      item            : {{ name }}.cxx
        generated by    : {{ maker }}
        date            : {{ date }}
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : {{ codegenversion }}
        language        : C++
*/

#include "{{ name }}.hxx"
#include <iostream>
#include <dueca/dcoprint.hxx>
{{ arraydimsdec }}
{{ assertinclude }}
#if !defined(__DCO_NOPACK)
#include <dueca/AmorphStore.hxx>
#include <dueca/PackUnpackTemplates.hxx>
#endif
#include <dueca/DataWriterArraySize.hxx>
{{ debugcmd }}
#if !defined(__DCO_STANDALONE)
#include <dueca/Arena.hxx>
#include <dueca/ArenaPool.hxx>
#include <dueca/DataClassRegistrar.hxx>
#include <dueca/CommObjectMemberAccess.hxx>
#include <dueca/DCOFunctor.hxx>
#include <dueca/DCOMetaFunctor.hxx>
{{ scriptcreatebodyinc }}
#define DO_INSTANTIATE
#include <dueca/DataSetSubsidiary.hxx>
#endif{{ plug_body_include }}

// getclassname implementation, always namespace dueca
namespace dueca {
  template<>
  const char* getclassname<::{{ objprefix }}{{ name }}>()
  { return "{{ name }}"; }
}

{{ namespacecmd0 }}{{ arraydimsimp }}{{ extraincludebody }}

#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a {{ name }} object{{ accessstatics }}

// assemble the above entries into a table in the order in which they
// appear in the {{ name }} object
static const ::dueca::CommObjectDataTable entriestable[] = { {{ tableentries }}
  { NULL }
};

#endif

// class name, static
const char * const {{ name }}::classname = "{{ name }}";

// magic number, hashed from class name and member names / classes
const uint32_t {{ name }}::magic_check_number=0x{{ "%0x" % magic }};

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  ({{ name }}::classname, {{ registrarparent }},
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<{{ name }}>());
{{ parametertable }}
#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
{{ name }}::{{ name }}({{ defaultconstructorargumentsimp }}){{ defaultconstructorlist }}
{ {{ defaultconstructorbody }}{{ constructorcode }}
  DOBS("default constructor {{ name }}");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR{{ completeconstructorimp }}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR{{ completeconstructorimp_s }}
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
{{ name }}::{{ name }}(const {{ name }}& other){{ copyconstructorlist }}
{ {{ copyconstructorbody }}
  DOBS("copy constructor {{ name }}");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
{{ name }}::{{ name }}({{ inclassprefix }}AmorphReStore& s){{ parent and " :" or ''}}
{%- if parent %}
  {{ parent }}(s)
{%- endif %}
{
  // { amorphconstructorbody }
  DOBS("amorph constructor {{ name }}");
  {%- for m in datamembers %}
  ::dueca::unpackobject(s, this->{{ m.name }},
                        dueca::dco_traits<{{ m.klass }}>());
  {%- endfor %}
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR){{ arraysizeinitconstructorimp }}
#endif

#ifndef __CUSTOM_DESTRUCTOR
{{ name }}::~{{ name }}()
{ {{ destructorbody }}
  DOBS("destructor {{ name }}");
}
#endif

#if !defined(__DCO_STANDALONE)
// Arena-supported operator new
void* {{ name }}::operator new(size_t size)
{
  DOBS("operator new {{ name }}");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof({{ name }}));
  return my_arena->alloc(size);
}

// For special cases, the placement operator new
void* {{ name }}::operator new(size_t size, void* mem)
{
  DOBS("placement operator new {{ name }}");
  return mem;
}

// With arena-supported delete
void {{ name }}::operator delete(void* v)
{
  DOBS("operator delete {{ name }}");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof({{ name }}));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void {{ name }}::packDataDiff(::dueca::AmorphStore& s, const {{ name }}& ref) const
{
  DOBS("packDataDiff {{ name }}");
  {%- if parent %}
  {{ parent }}::packDataDiff(s, ref);
  {%- endif %}
  ::dueca::IndexMemory im;// { amorphpackdiff }
  {%- for m in datamembers %}
  ::dueca::checkandpackdiff(this->{{ m.name }}, ref.{{ m.name }}, s, im,
                            dueca::dco_traits<{{ m.klass }}>());
  {%- endfor %}
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void {{ name }}::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData {{ name }}");
  //{ amorphunpackfirst }
  //{ amorphunpacksecond }
  {%- if parent %}
  {{ parent }}::unPackData(s);
  {%- endif %}
  {%- for m in datamembers %}
  ::dueca::unpackobject(s, this->{{ m.name }},
                        dueca::dco_traits<{{ m.klass }}>());
  {%- endfor %}
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void {{ name }}::unPackDataDiff({{ inclassprefix }}AmorphReStore& s)
{
  DOBS("unPackDataDiff {{ name }}");
  {%- if parent %}
  {{ parent }}::unPackDataDiff(s);
  {%- endif %}
  ::dueca::IndexRecall im;// { amorphunpackdiff }
  {%- for m in datamembers %}
  ::dueca::checkandunpackdiff(this->{{ m.name }}, s, im,
                              dueca::dco_traits<{{ m.klass }}>());
  {%- endfor %}
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool {{ name }}::operator == (const {{ name }}& other) const
{
  DOBS("operator == {{ name }}");{{ operatorequal }}
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
{{ name }}&
{{ name }}::operator=(const {{ name }}& other)
{
  DOBS("operator = {{ name }}");
  if (this == &other) return *this;{{ operatorassign }}
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void {{ name }}::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData {{ name }}");
  //{ amorphpackfirst }{ amorphpacksecond }
  {%- if parent %}
  {{ parent }}::packData(s);
  {%- endif %}
  {%- for m in datamembers %}
  ::dueca::packobject(s, this->{{ m.name }},
                      dueca::dco_traits<{{ m.klass }}>());
  {%- endfor %}
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & {{ name }}::print(std::ostream& s) const
{
  s << "{{ name }}(";
  {%- if parent %}
  {{ parent }}::print(s);
  {%- endif %}
  {%- for m in datamembers %}
  s << "{{ m.name }}=";
  ::dueca::dcoprint(s, this->{{ m.name }},
                    typename ::dueca::dco_traits<{{ m.klass }}>::ptype());
  s << {{ '")"' if loop.last else '","' }};  
  {%- endfor %}
  return s;
}
#endif

{{ namespacecmd1 }}{{ plug_body_code }}{{ createcodeimp }}{{ publicfunctionsimp }}
