/* ------------------------------------------------------------------ */
/*      item            : {{ name }}.hxx
        generated by    : {{ maker }}
        date            : {{ date }}
        category        : header file
        description     : DUECA Communication Object (DCO)
                          automatically generated by dueca-codegen
        codegen version : {{ codegenversion }}
        language        : C++{{ headercomments }}
*/

#pragma once

#include <inttypes.h>

#if !defined(__DCO_NOPACK)
namespace dueca {
class AmorphStore;
class AmorphReStore;
};
#endif

#if !defined(__DCO_STANDALONE)
#include <gencodegen.h>
#if GENCODEGEN != {{ codegenversion }}
#error "Generated {{ name }}.hxx too old, please clean with 'make mrproper'"
#endif
#include <dueca/CommObjectTraits.hxx>
#endif
#include <iostream>

{{ extraheader }}
#ifndef NESTED_DCO
#define NESTED_DCO
#define MASTER_DCO_{{ name }}
#endif
{{ typeincludes }}
#ifdef MASTER_DCO_{{ name }}
#undef MASTER_DCO_{{ name }}
#undef NESTED_DCO
#endif
{{ plug_header_include }}

{{ namespacecmd0 }}
{{ enumdec }}
{{ namespacecmd1 }}{{ extrainclude }}

namespace dueca {
  const char* const getString(const {{ objprefix }}{{ name }} &o);
  void readFromString({{ objprefix }}{{ name }} &o, const std::string& s);
  void getFirst({{ objprefix }}{{ name }} &o);
  bool getNext({{ objprefix }}{{ name }} &o);
}; // end namespace dueca

#if !defined(__DCO_NOPACK)
void packData(::dueca::AmorphStore& s,
              const {{ objprefix }}{{ name }} &o);
void unPackData(::dueca::AmorphReStore& s,
                {{ objprefix }}{{ name }} &o);
#endif

PRINT_NS_START;
/** Print an object of type {{ name }} */
inline std::ostream&
operator << (std::ostream& s, const {{ objprefix }}{{ name }}& o)
{ return s << dueca::getString(o); }
/** Read an enum of type {{ name }} */
inline std::istream&
operator >> (std::istream& s, {{ objprefix }}{{ name }}& o)
{ std::string tmp; s >> tmp; dueca::readFromString(o, tmp); return s; }
PRINT_NS_END;

/** This function retrieves the classname of {{ name }} */
template <>
const char* dueca::getclassname<{{objprefix}}{{name}}>();
template <>
const char* dueca::getenumintrep<{{objprefix}}{{name}}>();
template <>
inline const char* dueca::getclassname<const {{objprefix}}{{name}}>()
{ return dueca::getclassname<{{objprefix}}{{name}}>(); }

#if !defined(__DCO_STANDALONE)
namespace dueca {
template <>
struct dco_nested<{{ objprefix }}{{ name}}> : public dco_isenum { };
};
#endif
{{ plug_header_code }}