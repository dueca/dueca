/* ------------------------------------------------------------------ */
/*      item            : {{ name }}.hxx
        generated by    : {{ maker }}
        date            : {{ date }}
        category        : header file
        description     : DUECA Communication Object (DCO)
                          automatically generated by dueca-codegen
        codegen version : {{ codegenversion }}
        language        : C++{{ headercomments }}
*/

#pragma once
#if !defined(__DCO_NOPACK)
namespace dueca {
class AmorphStore;
class AmorphReStore;
struct DataWriterArraySize;
};
#endif

#if !defined(__DCO_STANDALONE)
namespace dueca {
struct CommObjectDataTable;
};

#include <gencodegen.h>
#if GENCODEGEN != {{ codegenversion }}
#error "Generated {{ name }}.hxx too old, please clean with 'make mrproper'"
#endif
#include <dueca/CommObjectTraits.hxx>
#endif
#include <iostream>
{{ extraheader }}
#ifndef NESTED_DCO
#define NESTED_DCO
#define MASTER_DCO
#endif
{{ typeincludes }}
#ifdef MASTER_DCO
#undef MASTER_DCO
#undef NESTED_DCO
#endif
{{ plug_header_include }}
{{ namespacecmd0 }} {{ packpragma }}
{{ classcomment }}
struct {{ name }}{{ inherits }}
{
  /** typedef for internal reference */
  typedef {{ name }} __ThisDCOType__;

public:
  /** The name of this class. */
  static const char* const classname;

{{ subtypecmd }}{{ memberdec }}
public:
  /** a "magic" number, hashed out of the class definition,
      that will be used to check consistency of the sent objects
      across the dueca nodes. */
  static const uint32_t magic_check_number;

  /** default constructor. */
  {{ name }}({{ defaultconstructorarguments }});
{{ completeconstructordec }}{{ completeconstructordec_s }}
  /** copy constructor. */
  {{ name }}(const {{ name }}& o);

#if !defined(__DCO_NOPACK)
  /** constructor to restore an {{ name }} from amorphous storage. */
  {{ name }}({{ inclassprefix }}AmorphReStore& r);
#endif{{ arraysizeinitconstructordec }}

  /** destructor. */
  ~{{ name }}();

#if !defined(__DCO_STANDALONE)
  /** new operator "new", which places objects not on a
      heap, but in one of the memory arenas. This to speed up
      memory management. */
  static void* operator new(size_t size);

  /** accompanying placement operator "new" */
  static void* operator new(size_t size, void* mem);

  /** new operator "delete", to go with the new version
      of operator new. */
  static void operator delete(void* p);

  /** placement "new", needed for stl. */
  inline static void* operator new(size_t size, {{ name }}*& o)
  { return reinterpret_cast<void*>(o); }
#endif

#if !defined(__DCO_NOPACK)
  /** packs the {{ name }} into amorphous storage. */
  void packData(::dueca::AmorphStore& s) const;

  /** packs the {{ name }} into amorphous storage.
      only differences with a previous object are packed. */
  void packDataDiff(::dueca::AmorphStore& s, const {{ name }}& ref) const;

  /** unpacks the {{ name }} from an amorphous storage. */
  void unPackData(::dueca::AmorphReStore& s);

  /** unpacks the differences for {{ name }}
      from an amorphous storage. */
  void unPackDataDiff(::dueca::AmorphReStore& s);
#endif

  /** Test for equality. */
  bool operator == (const {{ name }}& o) const;

  /** Test for inequality. */
  inline bool operator != (const {{ name }}& o) const
  { return !(*this == o); }

  /** Assignment operator. */
  {{ name }}& operator=(const {{ name }}& o);

  /** prints the {{ name }} to a stream. */
  std::ostream & print(std::ostream& s) const;{{ plug_header_classcode }}{{ createcodedec }}{{ extrainclude }}
};
{{ namespacecmd1 }}{{ endpackpragma }}
#if !defined(__DCO_NOPACK)
/** pack the object into amorphous storage. */
inline void packData(::dueca::AmorphStore& s,
                     const {{ objprefix }}{{ name }}& o)
{ o.packData(s); }

/** pack the differences between this object and another
    into amorphous storage. */
inline void packDataDiff(dueca::AmorphStore& s,
                         const {{ objprefix }}{{ name }}& o,
                         const {{ objprefix }}{{ name }}& ref)
{ o.packDataDiff(s, ref); }

/** unpack the object from amorphous storage. */
inline void unPackData(::dueca::AmorphReStore& s,
                       {{ objprefix }}{{ name }}& o)
{ o.unPackData(s); }

/** unpack the differences to this object from storage. */
inline void unPackDataDiff(dueca::AmorphReStore& s,
                           {{ objprefix }}{{ name }}& o)
{ o.unPackDataDiff(s); }
#endif
{{ publicfunctionsdec }}
namespace std {
/** print to a stream. */
inline std::ostream &
operator << (std::ostream& s, const {{ objprefix }}{{ name }}& o)
{ return o.print(s); }
};

// specialization of classname
template<>
const char* dueca::getclassname<{{ objprefix }}{{ name }}>();
template <>
inline const char* dueca::getclassname<const {{objprefix}}{{name}}>()
{ return dueca::getclassname<{{objprefix}}{{name}}>(); }

#if !defined(__DCO_STANDALONE)
namespace dueca {
/** Template specialization, defines a trait that is needed if
    {{ name }} is ever used inside other dco objects. */
template <>
struct dco_nested<{{ objprefix }}{{ name }}> : public dco_isnested { };{{ enumtraits }}
};

#endif
{{ plug_header_code }}


